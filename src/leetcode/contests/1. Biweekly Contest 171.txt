===========================================================
Problem 1 — Complete Prime Number
===========================================================
Topics: number theory, primality test, digit processing

Solution:
class Solution {
public:
    bool isPrime(long long x) {
        if (x < 2) return false;
        if (x % 2 == 0) return x == 2;
        for (long long i = 3; i * i <= x; i += 2)
            if (x % i == 0) return false;
        return true;
    }

    bool completePrime(int num) {
        string s = to_string(num);
        int n = s.size();

        long long val = 0;
        for (int i = 0; i < n; i++) {
            val = val * 10 + (s[i] - '0');
            if (!isPrime(val)) return false;
        }

        val = 0;
        long long mult = 1;
        for (int i = n - 1; i >= 0; i--) {
            val = (s[i] - '0') * mult + val;
            mult *= 10;
            if (!isPrime(val)) return false;
        }

        return true;
    }
};

Logic:
- A number is "complete prime" if every prefix and suffix is prime.
- Convert num to string, check all prefixes: must be prime.
- Check all suffixes (right → left buildup).
- Return true only if all checks pass.
===========================================================


===========================================================
Problem 2 — Minimum Operations to Make Binary Palindrome
===========================================================
Topics: bit manipulation, palindrome check, brute nearest search

Solution:
class Solution {
public:
    string toBinary(int x) {
        string s;
        while (x > 0) { s.push_back((x & 1) + '0'); x >>= 1; }
        reverse(s.begin(), s.end());
        return s;
    }

    bool isPal(const string &s) {
        int i = 0, j = s.size() - 1;
        while (i < j) if (s[i++] != s[j--]) return false;
        return true;
    }

    vector<int> minOperations(vector<int>& nums) {
        vector<int> pals;
        for (int x = 1; x <= 10000; x++)
            if (isPal(toBinary(x))) pals.push_back(x);

        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i], best = INT_MAX;
            for (int p : pals)
                best = min(best, abs(p - x));
            ans[i] = best;
        }
        return ans;
    }
};

Logic:
- Binary palindromes up to 10000 are few → precompute all.
- For each nums[i], compute min |nums[i] – palindrome|.
- Binary palindrome check takes ~O(10) time.
- Fully accurate for all constraints.
===========================================================


===========================================================
Problem 3 — Maximize Points After Choosing K Tasks
===========================================================
Topics: greedy, sorting, advantage calculation

Solution:
class Solution {
public:
    long long maxPoints(vector<int>& t1, vector<int>& t2, int k) {
        int n = t1.size();
        vector<pair<long long,int>> adv(n);
        for (int i = 0; i < n; i++)
            adv[i] = { (long long)t1[i] - t2[i], i };

        sort(adv.begin(), adv.end(), greater<>());
        long long ans = 0;

        for (int i = 0; i < k; i++)
            ans += t1[adv[i].second];

        for (int i = k; i < n; i++) {
            int idx = adv[i].second;
            ans += max((long long)t1[idx], (long long)t2[idx]);
        }
        return ans;
    }
};

Logic:
- adv[i] = t1[i] – t2[i]: benefit of using technique1 over technique2.
- Sort tasks by adv descending.
- Pick first k tasks with technique1 (forced).
- Remaining tasks pick max(t1, t2).
- Optimal greedy solution.
===========================================================


===========================================================
Problem 4 — Minimum Inversion Count in Subarrays of Fixed Length
===========================================================
Topics: fenwick tree, sliding window, coordinate compression

Solution:
class Solution {
public:
    struct Fenwick {
        int n; vector<long long> bit;
        Fenwick(int n): n(n), bit(n+1,0) {}
        void add(int i,long long v){ for(;i<=n;i+=i&-i) bit[i]+=v; }
        long long sum(int i){ long long s=0; for(;i>0;i-=i&-i) s+=bit[i]; return s; }
        long long range(int l,int r){ return (l>r?0:sum(r)-sum(l-1)); }
    };

    long long minInversionCount(vector<int>& nums,int k){
        int n=nums.size();
        vector<int> vals=nums;
        sort(vals.begin(),vals.end());
        vals.erase(unique(vals.begin(),vals.end()),vals.end());
        auto comp=[&](int x){return int(lower_bound(vals.begin(),vals.end(),x)-vals.begin())+1;};

        int m=vals.size();
        Fenwick BIT(m);
        long long inv=0,ans=LLONG_MAX;

        for(int i=0;i<k;i++){
            int x=comp(nums[i]);
            inv += BIT.range(x+1,m);
            BIT.add(x,1);
        }
        ans=min(ans,inv);

        for(int i=k;i<n;i++){
            int out=comp(nums[i-k]);
            int in =comp(nums[i]);

            long long out_contrib = BIT.range(1,out-1);
            inv -= out_contrib;
            BIT.add(out,-1);

            inv += BIT.range(in+1,m);
            BIT.add(in,1);

            ans=min(ans,inv);
        }
        return ans;
    }
};

Logic:
- Inversions counted using Fenwick Tree in O(log n).
- For first window: add each element, count previous elements > it.
- When sliding:
    - Removing leftmost element only removes pairs where it was LEFT element → count elements smaller than it.
    - Adding rightmost element adds pairs with elements greater than it.
- Track minimum inversion across all windows.
===========================================================
